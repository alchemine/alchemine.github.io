---
title: 14. 반복형, 반복자, 제너레이터
tags: Study_FluentPython
comment: true
---

# Remarks
이 글은 [전문가를 위한 파이썬(Fluent Python)](https://books.google.co.kr/books/about/%EC%A0%84%EB%AC%B8%EA%B0%80%EB%A5%BC_%EC%9C%84%ED%95%9C_%ED%8C%8C%EC%9D%B4%EC%8D%AC.html?id=NJpIDwAAQBAJ&printsec=frontcover&source=kp_read_button&redir_esc=y#v=onepage&q&f=false)을 정리한 자료입니다.

<!--more-->

---

- `reprlib.repr()`: 문자열을 잘라 생성 (default: 30자)

1. 객체를 반복하기 전에 객체가 반복형인지 명시적으로 검사하는 것은 필요하지 않다.
    - `__iter__()`를 구현하는 객체만 반복형이라 간주하지만, 그렇지 않아도 반복가능하기 때문에 오히려 헷갈릴 수 있음 \
    `issubclass(cls, abc.Iterable)`, `isinstance(ins, abc.Iterable)`

### 1. Generator
1. `yield` 키워드를 포함하는 함수는 모두 generator 함수이다.
    ```python
    def __iter__(self):
      for word in self.words:
        yield word
      return
    ```
2. 반복문, `next()` 등을 이용하여 값을 가져올 수 있다.
    - `next()` 호출 시, 함수 본체에 있는 다음 `yield`로 진행하며, `next()`는 함수 본체가 중단된 곳에서 생성된 값을 평가한다.
    - 그래서 제너레이터 함수 안에 있는 `return`은 `StopIteration` 예외를 발생하게 만들 뿐이다.
3. 제너레이터 함수는 함수 본체를 포함하는 제너레이터 객체를 생성한다.
4. 바람직한 Sentence iterator 구현
    ```python
    import re
    import reprlib

    RE_WORD = re.compile("\w+")


    class Sentence:
        def __init__(self, text):
            self.text = text

        def __repr__(self):
            return f"Sentence({reprlib.repr(self.text)})"

        def __iter__(self):
            return (match.group() for match in RE_WORD.finditer(self.text))
    ```
5. 무한 수열을 생성하는 경우에도 유용하게 사용된다.
    - `itertools.count()`: 무한 등차수열 생성
    